from django.db import models
from datetime import date, timedelta
from django_x509.base.models import AbstractCa, AbstractCert
import uuid, secrets
from django.db.models.signals import post_delete
from django.dispatch import receiver
from OpenSSL import crypto
from django.utils import timezone
from getEAP_TLS.settings import BASE_URL, API_PATH
import swapper

class MyCustomCA(AbstractCa):
    """
    Custom CA class to add crlDistributionPoints extension and correct serial number format
    """
    class Meta(AbstractCa.Meta):
        abstract = False
        swappable = swapper.swappable_setting('getEAP_TLS', 'MyCustomCA')

    def __init__(self, *args, **kwargs):
        self.crl_dp_url = None  # default value
        super().__init__(*args, **kwargs)

    def _add_extensions(self, cert):
        cert = super()._add_extensions(cert)

        crl_dp = 'URI:' + self.crl_dp_url

        cert.add_extensions([
            crypto.X509Extension(
                b'crlDistributionPoints',
                False,
                bytes(crl_dp, 'utf8')
            )
        ])

        return cert
    
    @property
    def crl(self):
        """
        Returns up to date CRL of this CA, with hex serials
        """
        now = timezone.now()
        revoked_certs = self.certificates.filter(
            revoked=True, validity_start__lte=now, validity_end__gte=now
        )
        crl = crypto.CRL()
        now_str = now.strftime("%Y%m%d%H%M%SZ")  
        print(now_str)
        for cert in revoked_certs:
            revoked = crypto.Revoked()
            hex_serial = format(int(cert.serial_number), 'x')
            revoked.set_serial(bytes(hex_serial, 'utf8'))
            revoked.set_reason(b'unspecified')
            revoked.set_rev_date(bytes(now_str, 'utf8'))
            crl.add_revoked(revoked)

        return crl.export(self.x509, self.pkey, days=1, digest=b'sha256')

class MyCustomCert(AbstractCert):
    """
    Custom Certificate model that uses MyCustomCA as its CA.
    """
    class Meta(AbstractCa.Meta):
        abstract = False
        swappable = swapper.swappable_setting('getEAP_TLS', 'MyCustomCert')
    
    ca = models.ForeignKey(
        MyCustomCA,
        on_delete=models.CASCADE,
        related_name="certificates",
        blank=False,
        null=False
    )

class WifiUser(models.Model):
    """
    Model that represents a user that will be granted access to a wifi network
    """
    # Registration fields
    name = models.CharField(max_length=64, blank=False)
    email = models.EmailField(max_length=64, blank=False)
    id_document = models.CharField(max_length=20, blank=False)
    wifiLocation = models.ForeignKey('WifiNetworkLocation', on_delete=models.SET_NULL, blank=False, null=True)

    # Autogenerated fields
    certificate = models.ForeignKey(MyCustomCert, on_delete=models.SET_NULL, blank=False, null=True)
    user_uuid = models.UUIDField(default=None, blank=True, null=True) 
    certificates_symmetric_key = models.BinaryField(max_length=32, blank=True, null=True)
    allow_access = models.BooleanField(default=False)

    def save(self, *args, **kwargs):
        from getEAP_TLS.utils import send_mail # Import here to avoid circular import
        if not self.wifiLocation:
            raise ValueError("WifiLocation is required to create a certificate.")

        # Generate a UUID for the user if it doesn't exist
        if not self.user_uuid:
            self.user_uuid = uuid.uuid4()
        
        # Generate a symmetric key for the certificates if it doesn't exist
        if not self.certificates_symmetric_key:
            self.certificates_symmetric_key = secrets.token_bytes(32)

        # Check if the name, id_document, email or wifiLocation changed: 
        # If any of these fields changed, we need to create a new certificate
        if self.pk:
            original = WifiUser.objects.get(pk=self.pk)
            if (self.name != original.name or
                self.id_document != original.id_document or
                self.email != original.email or
                self.wifiLocation != original.wifiLocation):
                # If any of these fields changed, we need to create a new certificate
                self.certificate = None
                self.allow_access = False
        
        # Check if the certificate doesnt exist (the user is new/an important field changed)
        if not self.certificate:
            # Get the certificate's CA from the wifi location
            ca = self.wifiLocation.certificates_CA

            # Create the certificate
            cert = MyCustomCert.objects.create(
                name=f"{self.name}'s Certificate",
                ca=ca,
                common_name=self.name,
                email=self.email,
                validity_start=ca.validity_start,
                validity_end=ca.validity_end,
            )

            self.certificate = cert
            send_mail(self)
        
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    
    def revoke_certificate(self):
        """
        Revoke the certificate and mark the user as not allowed to access the wifi network
        """
        from getEAP_TLS.radius.radius_certs import mark_ssid_to_update_crl # Import here to avoid circular import
        if self.certificate:
            self.certificate.revoke()
            self.allow_access = False
            self.save()
            # Export the new CRL
            mark_ssid_to_update_crl(self.wifiLocation)
        else:
            raise ValueError("Certificate does not exist for this user.")


class WifiNetworkLocation(models.Model):
    """
    Model that represents the event/organization where the wifi network is located at
    """
    # Registration fields
    ### Mandatory fields
    name = models.CharField(max_length=64, blank=False) 
    SSID = models.CharField(max_length=32, blank=False) 

    ### Optional fields
    location = models.CharField(max_length=64, blank=True, null=True)
    description = models.TextField(blank=True, null=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)

    # Autogenerated fields
    certificates_CA = models.ForeignKey(MyCustomCA, on_delete=models.SET_NULL, blank=False, null=True)
    radius_Certificate = models.ForeignKey(MyCustomCert, on_delete=models.SET_NULL, blank=False, null=True)

    def save(self, *args, **kwargs):
        from getEAP_TLS.radius.radius_certs import export_certificates # Import here to avoid circular import
        # Establish default values for start and end dates:
        if not self.start_date:
            start_date = date.today()
        else:
            start_date = self.start_date
        if not self.end_date:
            end_date = start_date + timedelta(days=10*365+2)
        else:
            end_date = self.end_date

        if not self.pk: # its a new object, so we save first to generate the id in the database
            super().save(*args, **kwargs)

        if not self.certificates_CA:
            # Create the CA for the certificates
            ca = MyCustomCA()
            ca.name=f"{self.name}'s CA"    
            ca.common_name=self.name
            ca.validity_start=start_date
            ca.validity_end=end_date
            ca.crl_dp_url=f"{BASE_URL}{API_PATH}events/{self.id}/crl"
            ca.save()
            self.certificates_CA = ca

        if not self.radius_Certificate:
            # Create the radius certificate
            radius_cert = MyCustomCert.objects.create(
                name=f"{self.name}'s Radius Certificate",
                ca=ca,
                common_name=self.name,
                validity_start=ca.validity_start,
                validity_end=ca.validity_end,
            )

            self.radius_Certificate = radius_cert

        export_certificates(self)
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    

@receiver(post_delete, sender=WifiNetworkLocation)
def signal_function_name(sender, instance, using, **kwargs):
    from getEAP_TLS.radius.radius_certs import mark_ssid_for_deletion # Import here to avoid circular import
    instance.radius_Certificate.delete()
    instance.certificates_CA.delete()
    mark_ssid_for_deletion(instance)
