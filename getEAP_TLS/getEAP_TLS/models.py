from django.db import models
from datetime import date, timedelta
from django_x509.models import Cert, Ca
import uuid, secrets

class WifiUser(models.Model):
    """
    Model that represents a user that will be granted access to a wifi network
    """
    # Registration fields
    name = models.CharField(max_length=64, blank=False)
    email = models.EmailField(max_length=64, blank=False)
    id_document = models.CharField(max_length=20, blank=False)
    wifiLocation = models.ForeignKey('WifiNetworkLocation', on_delete=models.SET_NULL, blank=False, null=True)

    # Autogenerated fields
    certificate = models.ForeignKey(Cert, on_delete=models.SET_NULL, blank=False, null=True)
    user_uuid = models.UUIDField(default=None, blank=True, null=True) 
    certificates_symmetric_key = models.BinaryField(max_length=32, blank=True, null=True)
    allow_access = models.BooleanField(default=False)

    def save(self, *args, **kwargs):
        from getEAP_TLS.utils import send_mail # Import here to avoid circular import
        if not self.wifiLocation:
            raise ValueError("WifiLocation is required to create a certificate.")

        # Generate a UUID for the user if it doesn't exist
        if not self.user_uuid:
            self.user_uuid = uuid.uuid4()
        
        # Generate a symmetric key for the certificates if it doesn't exist
        if not self.certificates_symmetric_key:
            self.certificates_symmetric_key = secrets.token_bytes(32)

        # Check if the name, id_document, email or wifiLocation changed: 
        # If any of these fields changed, we need to create a new certificate
        if self.pk:
            original = WifiUser.objects.get(pk=self.pk)
            if (self.name != original.name or
                self.id_document != original.id_document or
                self.email != original.email or
                self.wifiLocation != original.wifiLocation):
                # If any of these fields changed, we need to create a new certificate
                self.certificate = None
                self.allow_access = False
        
        # Check if the certificate doesnt exist (the user is new/an important field changed)
        if not self.certificate:
            # Get the certificate's CA from the wifi location
            ca = self.wifiLocation.certificates_CA

            # Create the certificate
            cert = Cert.objects.create(
                name=f"{self.name}'s Certificate",
                ca=ca,
                common_name=self.name,
                email=self.email,
                validity_start=ca.validity_start,
                validity_end=ca.validity_end,
            )

            self.certificate = cert
            send_mail(self)
        
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name


class WifiNetworkLocation(models.Model):
    """
    Model that represents the event/organization where the wifi network is located at
    """
    # Registration fields
    ### Mandatory fields
    name = models.CharField(max_length=64, blank=False) 
    SSID = models.CharField(max_length=32, blank=False) 

    ### Optional fields
    location = models.CharField(max_length=64, blank=True, null=True)
    description = models.TextField(blank=True, null=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)

    # Autogenerated fields
    certificates_CA = models.ForeignKey(Ca, on_delete=models.SET_NULL, blank=False, null=True)
    radius_Certificate = models.ForeignKey(Cert, on_delete=models.SET_NULL, blank=False, null=True)

    def save(self, *args, **kwargs):
        from getEAP_TLS.radius.radius_certs import export_certificates # Import here to avoid circular import
        # Establish default values for start and end dates:
        if not self.start_date:
            start_date = date.today()
        else:
            start_date = self.start_date
        if not self.end_date:
            end_date = start_date + timedelta(days=10*365+2)
        else:
            end_date = self.end_date

        if not self.certificates_CA:
            # Create the CA for the certificates
            ca = Ca.objects.create(
                name=f"{self.name}'s CA",
                common_name=self.name,
                validity_start=start_date,
                validity_end=end_date,
            )

            self.certificates_CA = ca

        if not self.radius_Certificate:
            # Create the radius certificate
            radius_cert = Cert.objects.create(
                name=f"{self.name}'s Radius Certificate",
                ca=ca,
                common_name=self.name,
                validity_start=ca.validity_start,
                validity_end=ca.validity_end,
            )

            self.radius_Certificate = radius_cert

        export_certificates(self)
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name