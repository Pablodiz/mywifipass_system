# Copyright (c) 2025, Pablo Diz de la Cruz
# All rights reserved.
# Licensed under the BSD 3-Clause License. See LICENSE file in the project root for full license information.

from django.db import models
from datetime import date, timedelta
from django_x509.base.models import AbstractCa, AbstractCert
import uuid, secrets
from django.db.models.signals import post_delete
from django.dispatch import receiver
from OpenSSL import crypto
from django.utils import timezone
from mywifipass.settings import BASE_URL, API_PATH

class MyCustomCA(AbstractCa):
    """
    Custom CA class to add crlDistributionPoints extension and correct serial number format
    """
    class Meta(AbstractCa.Meta):
        abstract = False

    def __init__(self, *args, **kwargs):
        self.crl_dp_url = None  # default value
        super().__init__(*args, **kwargs)

    def _add_extensions(self, cert):
        cert = super()._add_extensions(cert)

        crl_dp = 'URI:' + self.crl_dp_url

        cert.add_extensions([
            crypto.X509Extension(
                b'crlDistributionPoints',
                False,
                bytes(crl_dp, 'utf8')
            )
        ])

        return cert

    def sign_certificate(self, cert):
        """
        Sign a certificate using this CA's private key
        
        Args:
            cert: X509 certificate object to be signed
            
        Returns:
            The signed certificate
        """
        # Set the issuer of the certificate to this CA
        cert.set_issuer(self.x509.get_subject())
        
        # Sign the certificate with this CA's private key
        cert.sign(self.pkey, str(self.digest))
        
        return cert

    @property
    def crl(self):
        """
        Returns up to date CRL of this CA, with hex serials
        """
        now = timezone.now()
        revoked_certs = self.certificates.filter(
            revoked=True, validity_start__lte=now, validity_end__gte=now
        )
        crl = crypto.CRL()
        now_str = now.strftime("%Y%m%d%H%M%SZ")  
        for cert in revoked_certs:
            revoked = crypto.Revoked()
            hex_serial = format(int(cert.serial_number), 'x')
            revoked.set_serial(bytes(hex_serial, 'utf8'))
            revoked.set_reason(b'unspecified')
            revoked.set_rev_date(bytes(now_str, 'utf8'))
            crl.add_revoked(revoked)

        return crl.export(self.x509, self.pkey, days=1, digest=b'sha256')

class MyCustomCert(AbstractCert):
    """
    Custom Certificate model that uses MyCustomCA as its CA.
    """
    class Meta(AbstractCert.Meta):
        abstract = False
    
    ca = models.ForeignKey(
        MyCustomCA,
        on_delete=models.CASCADE,
        related_name="certificates",
        blank=False,
        null=False
    )

    def save(self, *args, return_cert_fields=False, **kwargs):
        generate = False
        if not self.pk:
            generate = True
        super().save(*args, **kwargs) #generate the pk 
        if generate:
            # Automatically determine serial number
            if not self.serial_number:
                self.serial_number = self._generate_serial_number()
            self._generate()
            cert = self.certificate
            key = self.private_key
            # Clean the fields to avoid saving the cert and key in the database
            self.certificate = ''
            self.private_key = ''
            kwargs['force_insert'] = False
            super().save(*args, **kwargs)
            if return_cert_fields:
                return cert, key
        if return_cert_fields:
            return self.certificate, self.private_key

class WifiUser(models.Model):
    """
    Model that represents a user that will be granted access to a wifi network
    """
    # Registration fields
    name = models.CharField(max_length=64, blank=False)
    email = models.EmailField(max_length=64, blank=False)
    id_document = models.CharField(max_length=20, blank=False)
    wifiLocation = models.ForeignKey('WifiNetworkLocation', on_delete=models.CASCADE, blank=False, null=True, db_column='location_uuid')

    # Autogenerated fields
    certificate = models.ForeignKey(MyCustomCert, on_delete=models.SET_NULL, blank=False, null=True)
    user_uuid = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4) 
    certificates_symmetric_key = models.BinaryField(max_length=32, blank=True, null=True)
    has_attended = models.BooleanField(default=False)
    allow_access_expiration = models.DateTimeField(blank=True, null=True)
    has_downloaded_pass = models.BooleanField(default=False)
    email_sent = models.BooleanField(default=False, help_text="Indicates if registration email has been sent to the user")
    email_sent_date = models.DateTimeField(blank=True, null=True, help_text="Date when the last email was sent")
    android_version = models.CharField(blank=True, null=True)
    @property
    def is_user_authorized(self):
        if self.wifiLocation.requires_validator:
            # User needs to be validated by admin
            if not self.allow_access_expiration or self.allow_access_expiration <= timezone.now():
                return False
            else:
                return True
        else: 
            return True

    def deauthorize(self):
        """
        Deauthorize the user
        """
        self.has_attended = True
        self.allow_access_expiration = None
        self.save(send_email=False)

    def sign_csr(self, csr_pem: str) -> tuple:
        """
        Sign a CSR for the user

        Args:
            csr_pem: The PEM encoded CSR to be signed

        Returns:
            Tuple containing (certificate_pem, ca_certificate_pem)
        """
        if not self.wifiLocation:
            raise ValueError("WifiNetworkLocation is required to sign a CSR.")
        
        if self.certificate:
            self.revoke_certificate()

        # Get the certificate's CA from the wifi location
        ca = self.wifiLocation.certificates_CA

        # Load the CSR
        csr = crypto.load_certificate_request(crypto.FILETYPE_PEM, csr_pem)

        # Create a new X509 certificate
        cert = crypto.X509()
        
        # Fill subject from CSR
        cert.set_subject(csr.get_subject())
        
        # Set certificate properties
        cert.set_version(0x2)  # version 3
        cert.set_serial_number(int(str(uuid.uuid4().int)[:16]))  # Generate serial number
        cert.set_notBefore(bytes(str(ca.validity_start.strftime('%Y%m%d%H%M%SZ')), 'utf8'))
        cert.set_notAfter(bytes(str(ca.validity_end.strftime('%Y%m%d%H%M%SZ')), 'utf8'))
        
        # Set the public key from the CSR
        cert.set_pubkey(csr.get_pubkey())
        
        # Add basic extensions for end-entity certificate
        cert.add_extensions([
            crypto.X509Extension(b'basicConstraints', False, b'CA:FALSE'),
            crypto.X509Extension(b'keyUsage', True, b'digitalSignature,keyEncipherment'),
            crypto.X509Extension(b'subjectKeyIdentifier', False, b'hash', subject=cert)
        ])
        
        # Add authorityKeyIdentifier
        cert.add_extensions([
            crypto.X509Extension(
                b'authorityKeyIdentifier',
                False,
                b'keyid:always,issuer:always',
                issuer=ca.x509
            )
        ])

        # Sign the certificate with the CA
        signed_cert = ca.sign_certificate(cert)

        # Convert to PEM format
        certificate_pem = crypto.dump_certificate(crypto.FILETYPE_PEM, signed_cert).decode('utf-8')
        ca_certificate_pem = ca.certificate

        # Create and save the certificate record
        cert_record = MyCustomCert(
            name=f"{self.name}'s Certificate",
            ca=ca,
            common_name=self.name,
            email=self.email,
            validity_start=ca.validity_start,
            validity_end=ca.validity_end,
            serial_number=str(signed_cert.get_serial_number()),
            certificate=certificate_pem,
            private_key=''  # Private key is not available when signing a CSR
        )
        
        cert_record.save()
        self.certificate = cert_record
        self.save()

        return certificate_pem, ca_certificate_pem
    
    # def create_certificate(self) -> tuple:
    #     """
    #     Create a certificate for the user

    #     Returns the MyCustomCert object, the certificate and the private key
    #     """
    #     if not self.wifiLocation:
    #         raise ValueError("WifiNetworkLocation is required to create a certificate.")
        
    #     if self.certificate:
    #         self.revoke_certificate()

    #     # Get the certificate's CA from the wifi location
    #     ca = self.wifiLocation.certificates_CA

    #     # Create the certificate
    #     cert = MyCustomCert(
    #         name=f"{self.name}'s Certificate",
    #         ca=ca,
    #         common_name=self.name,
    #         email=self.email,
    #         validity_start=ca.validity_start,
    #         validity_end=ca.validity_end,
    #     )

    #     certificate_pem, private_key_pem = cert.save(return_cert_fields=True)
        
    #     return cert, certificate_pem, private_key_pem         

    def save(self, send_email: bool = True, *args, **kwargs):
        from mywifipass.utils import send_mail
        if not self.wifiLocation:
            raise ValueError("WifiNetworkLocation is required to create a WifiUser.")
        
        # Generate a UUID for the user if it doesn't exist
        if not self.user_uuid:
            while True:
                # Generate a new UUID
                new_uuid = uuid.uuid4()
                # Check if the UUID already exists in the database
                if not WifiUser.objects.filter(user_uuid=new_uuid).exists():
                    self.user_uuid = new_uuid
                    break

        # Generate a symmetric key for the certificates if it doesn't exist
        if not self.certificates_symmetric_key:
            self.certificates_symmetric_key = secrets.token_bytes(32)

        # Check if the certificate exists
        # If it does, check if the name, id_document, email or wifiLocation changed: 
        # If any of these fields changed, revoke the old one, remove the cert from the user and send a mail 
        # telling the user that the certificate was revoked and they should contact the organization
        update = False
        
        # Check if this is an update (user already exists) vs new user
        if self.pk:
            try:
                original = WifiUser.objects.get(user_uuid=self.user_uuid)
                # Check if important fields changed
                if (self.name != original.name or
                        self.id_document != original.id_document or
                        self.email != original.email or
                        self.wifiLocation != original.wifiLocation):
                    update = True
                    
            except WifiUser.DoesNotExist:
                # This is a new user, no need to check for changes
                pass
        
        # Mark email as not sent if user data changed
        if update and hasattr(self, 'email_sent'):
            self.email_sent = False
            self.email_sent_date = None

        super().save(*args, **kwargs)
        
        # Send email based on network settings and user email status
        if (send_email and self.wifiLocation and 
            hasattr(self.wifiLocation, 'send_emails_automatically') and 
            self.wifiLocation.send_emails_automatically and 
            hasattr(self, 'email_sent') and not self.email_sent):
            send_mail(self, update=update)
            self.email_sent = True
            self.email_sent_date = timezone.now()
            super().save(update_fields=['email_sent', 'email_sent_date'])
            

    def send_email_manually(self):
        """Send email to user and mark as sent"""
        from mywifipass.utils import send_mail
        try:
            if hasattr(self, 'email_sent'):
                send_mail(self, update=False)
                self.email_sent = True
                self.email_sent_date = timezone.now()
                self.save(update_fields=['email_sent', 'email_sent_date'], send_email=False)
                return True, "Email sent successfully"
            else:
                return False, "Email functionality not available for this user"
        except Exception as e:
            return False, str(e)
            

    def __str__(self):
        return self.name
    
    def revoke_certificate(self):
        """
        Revoke the certificate and mark the user as not allowed to access the wifi network
        """
        from mywifipass.radius.radius_certs import mark_ssid_to_update_crl # Import here to avoid circular import
        if self.certificate:
            self.certificate.revoke()
            # Export the new CRL
            mark_ssid_to_update_crl(self.wifiLocation)
        else:
            raise ValueError("Certificate does not exist for this user.")
    class Meta:
        verbose_name = "Wifi Client"
        verbose_name_plural = "Wifi Clients"
        ordering = ['name']
        unique_together = (('user_uuid', 'wifiLocation'),) 

class WifiNetworkLocation(models.Model):
    """
    Model that represents the event/organization where the wifi network is located at
    """
    # Registration fields
    ### Mandatory fields
    name = models.CharField(unique=True, max_length=64, blank=False) 
    SSID = models.CharField(unique=True, max_length=32, blank=False) 

    ### Optional fields
    location = models.CharField(max_length=64, blank=True, null=True)
    description = models.TextField(blank=True, null=True)
    brief_description = models.TextField(blank=True, null=True)
    start_date = models.DateField(blank=True, null=True, default=date.today)
    end_date = models.DateField(blank=True, null=True, default = date.today() + timedelta(days=10*365+2))
    form_link = models.URLField(blank=True, null=True)
    is_registration_open = models.BooleanField(default=True)
    is_enabled_in_radius = models.BooleanField(default=True)
    is_visible_in_web = models.BooleanField(default=True)
    requires_validator = models.BooleanField(default=True, help_text="If True, users need to be validated by an admin before accessing certificates")
    send_emails_automatically = models.BooleanField(default=True, help_text="If True, emails are sent automatically when users register or are updated")
    logo = models.ImageField(upload_to='', blank=True, null=True)
    
    # Autogenerated fields
    certificates_CA = models.ForeignKey(MyCustomCA, on_delete=models.SET_NULL, blank=False, null=True)
    radius_Certificate = models.ForeignKey(MyCustomCert, on_delete=models.SET_NULL, blank=False, null=True)
    location_uuid = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4)
    
    class Meta:
        verbose_name = "Wifi Network"
        verbose_name_plural = "Wifi Networks"
        ordering = ['name']

    def create_ca_certificates(self):
        from mywifipass.api.urls import crl_url
        ca = MyCustomCA(
            name=f"{self.name}'s CA",
            common_name=self.name,
            validity_start=self.start_date,
            validity_end=self.end_date,
        )
        ca.crl_dp_url= crl_url(self)


        ca.save()

        self.certificates_CA = ca
        
        for user in WifiUser.objects.filter(wifiLocation=self):
            if user.certificate: #TODO rethink this
                user.save()  # Save the user to delete the certificate and notify they need a new one

    def save(self, *args, **kwargs):
        from mywifipass.radius.radius_certs import export_certificates, mark_ssid_for_deletion # Import here to avoid circular import
        
        # If the location_uuid is not set, we need to generate a new one
        if not self.location_uuid:
            while True:
                # Generate a new UUID
                new_uuid = uuid.uuid4()
                # Check if the UUID already exists in the database
                if not WifiNetworkLocation.objects.filter(location_uuid=new_uuid).exists():
                    self.location_uuid = new_uuid
                    super().save(*args, **kwargs)
                    break
                    
        updated = False

        # Check if the name, start date or end date changed:
        original = WifiNetworkLocation.objects.filter(location_uuid=self.location_uuid).first()
        if original:
            if original.name != self.name or original.start_date != self.start_date or  original.end_date != self.end_date:
                # If the name, start date or end date changed, we need to create a new CA and server certificates
                updated = True

        # Check if the CA certificate exists, if not create it
        if not self.certificates_CA or updated:
            # Create/update the CA certificate
            self.create_ca_certificates()

        # If enabled, we generate and export the certificates to the radius server
        if self.is_enabled_in_radius:
            if updated:
                mark_ssid_for_deletion(original)
            export_certificates(self)
            
        if original:
            if self.is_enabled_in_radius != original.is_enabled_in_radius:
                if self.is_enabled_in_radius:
                    export_certificates(self)
                else:
                    mark_ssid_for_deletion(original)
        
        #TODO this could be optimized
        
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    

@receiver(post_delete, sender=WifiNetworkLocation)
def signal_function_name(sender, instance, using, **kwargs):
    from mywifipass.radius.radius_certs import mark_ssid_for_deletion # Import here to avoid circular import
    if instance.certificates_CA:
        instance.certificates_CA.delete()
    # The radiusCertificate will be revoked when calling mark_ssid_for_deletion
    mark_ssid_for_deletion(instance)


@receiver(post_delete, sender=WifiUser)
def signal_function_name(sender, instance, using, **kwargs):
    try: 
        if instance.certificate:
            instance.certificate.revoke()
            instance.certificate = None
    except:
        pass