from django.db import models
from datetime import date, timedelta
from django_x509.base.models import AbstractCa, AbstractCert
import uuid, secrets
from django.db.models.signals import post_delete
from django.dispatch import receiver
from OpenSSL import crypto
from django.utils import timezone
from mywifipass.settings import BASE_URL, API_PATH
import swapper

class MyCustomCA(AbstractCa):
    """
    Custom CA class to add crlDistributionPoints extension and correct serial number format
    """
    class Meta(AbstractCa.Meta):
        abstract = False
        swappable = swapper.swappable_setting('mywifipass', 'MyCustomCA')

    def __init__(self, *args, **kwargs):
        self.crl_dp_url = None  # default value
        super().__init__(*args, **kwargs)

    def _add_extensions(self, cert):
        cert = super()._add_extensions(cert)

        crl_dp = 'URI:' + self.crl_dp_url

        cert.add_extensions([
            crypto.X509Extension(
                b'crlDistributionPoints',
                False,
                bytes(crl_dp, 'utf8')
            )
        ])

        return cert
    
    @property
    def crl(self):
        """
        Returns up to date CRL of this CA, with hex serials
        """
        now = timezone.now()
        revoked_certs = self.certificates.filter(
            revoked=True, validity_start__lte=now, validity_end__gte=now
        )
        crl = crypto.CRL()
        now_str = now.strftime("%Y%m%d%H%M%SZ")  
        print(now_str)
        for cert in revoked_certs:
            revoked = crypto.Revoked()
            hex_serial = format(int(cert.serial_number), 'x')
            revoked.set_serial(bytes(hex_serial, 'utf8'))
            revoked.set_reason(b'unspecified')
            revoked.set_rev_date(bytes(now_str, 'utf8'))
            crl.add_revoked(revoked)

        return crl.export(self.x509, self.pkey, days=1, digest=b'sha256')

class MyCustomCert(AbstractCert):
    """
    Custom Certificate model that uses MyCustomCA as its CA.
    """
    class Meta(AbstractCa.Meta):
        abstract = False
        swappable = swapper.swappable_setting('mywifipass', 'MyCustomCert')
    
    ca = models.ForeignKey(
        MyCustomCA,
        on_delete=models.CASCADE,
        related_name="certificates",
        blank=False,
        null=False
    )

    def save(self, *args, return_cert_fields=False, **kwargs):
        generate = False
        if not self.pk:
            generate = True
        super().save(*args, **kwargs) #generate the pk 
        if generate:
            # Automatically determine serial number
            if not self.serial_number:
                self.serial_number = self._generate_serial_number()
            self._generate()
            cert = self.certificate
            key = self.private_key
            # Clean the fields to avoid saving the cert and key in the database
            self.certificate = ''
            self.private_key = ''
            kwargs['force_insert'] = False
            super().save(*args, **kwargs)
            if return_cert_fields:
                return cert, key
        if return_cert_fields:
            return self.certificate, self.private_key

class WifiUser(models.Model):
    """
    Model that represents a user that will be granted access to a wifi network
    """
    # Registration fields
    name = models.CharField(max_length=64, blank=False)
    email = models.EmailField(max_length=64, blank=False)
    id_document = models.CharField(max_length=20, blank=False)
    wifiLocation = models.ForeignKey('WifiNetworkLocation', on_delete=models.SET_NULL, blank=False, null=True, db_column='location_uuid')

    # Autogenerated fields
    certificate = models.ForeignKey(MyCustomCert, on_delete=models.SET_NULL, blank=False, null=True)
    user_uuid = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4) 
    certificates_symmetric_key = models.BinaryField(max_length=32, blank=True, null=True)
    has_attended = models.BooleanField(default=False)
    allow_access_expiration = models.DateTimeField(blank=True, null=True)
    has_downloaded_pass = models.BooleanField(default=False)

    def create_certificate(self, update:bool = False) -> tuple:
        """
        Create a certificate for the user

        Returns the MyCustomCert object, the certificate and the private key
        """
        from mywifipass.utils import send_mail
        if not self.wifiLocation:
            raise ValueError("WifiLocation is required to create a certificate.")
        
        if self.certificate and self.certificate.revoked:
            raise ValueError("The existing certificate is revoked. Cannot create a new certificate.")

        # Get the certificate's CA from the wifi location
        ca = self.wifiLocation.certificates_CA

        # Create the certificate
        cert = MyCustomCert(
            name=f"{self.name}'s Certificate",
            ca=ca,
            common_name=self.name,
            email=self.email,
            validity_start=ca.validity_start,
            validity_end=ca.validity_end,
        )

        certificate, private_key = cert.save(return_cert_fields=True)
        #send_mail(self, update=update)
        return cert, certificate, private_key         

    def save(self, *args, **kwargs):
        if not self.wifiLocation:
            raise ValueError("WifiLocation is required to create a certificate.")
        
        # Generate a UUID for the user if it doesn't exist
        if not self.user_uuid:
            while True:
                # Generate a new UUID
                new_uuid = uuid.uuid4()
                # Check if the UUID already exists in the database
                if not WifiUser.objects.filter(user_uuid=new_uuid).exists():
                    self.user_uuid = new_uuid
                    break

        # Generate a symmetric key for the certificates if it doesn't exist
        if not self.certificates_symmetric_key:
            self.certificates_symmetric_key = secrets.token_bytes(32)

        # Check if the name, id_document, email or wifiLocation changed: 
        # If any of these fields changed, we need to create a new certificate
        if self.pk and WifiUser.objects.filter(pk=self.pk).exists():
            original = WifiUser.objects.get(user_uuid=self.user_uuid)
            if (self.name != original.name or
                self.id_document != original.id_document or
                self.email != original.email or
                self.wifiLocation != original.wifiLocation):
                # If any of these fields changed, we need to create a new certificate
                self.certificate = self.create_certificate(update=True)
       
        # Check if the certificate doesnt exist (the user is new)
        if not self.certificate:
            self.certificate = self.create_certificate(update=False)
            
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    
    def revoke_certificate(self):
        """
        Revoke the certificate and mark the user as not allowed to access the wifi network
        """
        from mywifipass.radius.radius_certs import mark_ssid_to_update_crl # Import here to avoid circular import
        if self.certificate:
            self.certificate.revoke()
            self.save()
            # Export the new CRL
            mark_ssid_to_update_crl(self.wifiLocation)
        else:
            raise ValueError("Certificate does not exist for this user.")


class WifiNetworkLocation(models.Model):
    """
    Model that represents the event/organization where the wifi network is located at
    """
    # Registration fields
    ### Mandatory fields
    name = models.CharField(max_length=64, blank=False) 
    SSID = models.CharField(max_length=32, blank=False) 

    ### Optional fields
    location = models.CharField(max_length=64, blank=True, null=True)
    description = models.TextField(blank=True, null=True)
    brief_description = models.TextField(blank=True, null=True)
    start_date = models.DateField(blank=True, null=True, default=date.today)
    end_date = models.DateField(blank=True, null=True, default = date.today() + timedelta(days=10*365+2))
    form_link = models.URLField(blank=True, null=True)
    is_registration_open = models.BooleanField(default=True)
    is_enabled_in_radius = models.BooleanField(default=True)
    is_visible_in_web = models.BooleanField(default=True)
    logo = models.ImageField(upload_to='', blank=True, null=True)
    
    # Autogenerated fields
    certificates_CA = models.ForeignKey(MyCustomCA, on_delete=models.SET_NULL, blank=False, null=True)
    radius_Certificate = models.ForeignKey(MyCustomCert, on_delete=models.SET_NULL, blank=False, null=True)
    location_uuid = models.UUIDField(primary_key=True, editable=False, default=uuid.uuid4)

    def create_ca_certificates(self):
        ca = MyCustomCA(
            name=f"{self.name}'s CA",
            common_name=self.name,
            validity_start=self.start_date,
            validity_end=self.end_date,
            crl_dp_url=f"{BASE_URL}{API_PATH}events/{self.location_uuid}/crl"
        )
        ca.save()

        self.certificates_CA = ca
        
        for user in WifiUser.objects.filter(wifiLocation=self):
            try:
                user.certificate = user.create_certificate(update=True)
                user.save()
            except Exception as e:
                pass

    def save(self, *args, **kwargs):
        from mywifipass.radius.radius_certs import export_certificates, mark_ssid_for_deletion # Import here to avoid circular import
        
        # If the location_uuid is not set, we need to generate a new one
        if not self.location_uuid:
            while True:
                # Generate a new UUID
                new_uuid = uuid.uuid4()
                # Check if the UUID already exists in the database
                if not WifiNetworkLocation.objects.filter(location_uuid=new_uuid).exists():
                    self.location_uuid = new_uuid
                    super().save(*args, **kwargs)
                    break
                    
        updated = False

        # Check if the name, start date or end date changed:
        original = WifiNetworkLocation.objects.filter(location_uuid=self.location_uuid).first()
        if original:
            if original.name != self.name or original.start_date != self.start_date or  original.end_date != self.end_date:
                # If the name, start date or end date changed, we need to create a new CA and server certificates
                updated = True

        # Check if the CA certificate exists, if not create it
        if not self.certificates_CA or updated:
            # Create/update the CA certificate
            self.create_ca_certificates()

        # If enabled, we generate and export the certificates to the radius server
        if self.is_enabled_in_radius:
            if updated:
                mark_ssid_for_deletion(original)
            export_certificates(self)
            
        if original:
            if self.is_enabled_in_radius != original.is_enabled_in_radius:
                if self.is_enabled_in_radius:
                    export_certificates(self)
                else:
                    mark_ssid_for_deletion(original)
        
        
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    

@receiver(post_delete, sender=WifiNetworkLocation)
def signal_function_name(sender, instance, using, **kwargs):
    from mywifipass.radius.radius_certs import mark_ssid_for_deletion # Import here to avoid circular import
    instance.radius_Certificate.delete()
    instance.certificates_CA.delete()
    mark_ssid_for_deletion(instance)
